
# Advanced Analysis

---
## Advanced Static Analysis

> This involves using a decompiler and disassembler to reveal the assembly language of a piece of malware. From this you can reveal what the malware does.


Analysis with Cutter:
- open Cutter and load the binary, using aaa analysis
- find the `main` function under Functions to find the function where all other functions are run from 
- click on the Graph (main) tab to see the graph view of the main function. This will show a flow graph of the logical flow of the programme, from which you can deduce some functionality of the binary using strings and Windows API calls (all without knowning assembly).
- the Decompiler (main) tab will attempt to extrapolate the assembly langauge the disassembler generated into something similar to what the original source code looked like. This can be useful to see what parameters were passed to Windows APIs and reveal functionality about the binary. You can look at parameters these Windows APIs take online via Microsoft developer docs. 
- you can see strings in Cutter (Windows -> Strings) and correlate them with what section they appear in in the PE file (i.e. .text, .rdata, etc.)
- you can see imports (from the IAT) in Cutter (Windows -> Info... -> Imports) and from here you can right click on a imported function and select Show X-Refs to see where it is used in the binary (if it is used). From here you can jump straight to the dissambly code (function).
- you can also retrieve decompiled code from a dissassembly listing of a function by right clicking on the function and selecting Show In -> New Decompiler. This decompilers the assembly code using the Ghidra decompiler to give C-like pseudo-code.
- you can also see a dissassembly as a graph to see it's control flow, this can make it easier to see what the assembly code actually does or could do 


Code injection:
- code injection is a common evasion technique used by malware authors because the code that injects into a legitimate process, on the surface, appears legitimate with all it's metadata. Thus, it masks itself from detection.
- `CreateRemoteThread` is a Windows API often associated with code injection and if you see this in a malware sample you should check if this is used for code injection (i.e. look for `OpenProcess`, `VirtualAllocEx`, and `WriteProcessMemory` APIs)
- it's common for malware authors to inject shellcode into legitimate processes whereby they; write their shellcode into the body of the malware, write the bytes in the memory of a remote process, then execute this shellcode withe the `CreateRemoteThread` API
- this process can be seen using Process Hacker. Start Process Hacker -> run the code injector malware -> the malware will run, write memory space in the legitimate application, then write it's shellcode to the legitimate application, then execute this code, and then it would appear that the legitimate application is running (only now with the injected code)
- selecting the targetted process and clicking on the memory tab will reveal that a new memory location with full RWX permission has been created in the legitimate process, and it is from here the shellcode is being run from  


--- 
## Adanced Dynamic Analysis

> This is when you run the malware binary through a debugger and watch the assembly code execute.


Analysis with x32dbg:
- File -> Open -> binary name 
- F9 to run program (first pressing F9 will bring you to the entry point of the program - a breakpoint automatically set by the debugger)
- F8 to step over instruction (don't go into it if function call)
- F7 to step into instruction (goes into a function call)
- Ctrl+F2 to restart the program 
- F2 to set a breakpoint on the current instruction -- this will stop the program's execution at this instruction when you press run (F9)
- you want to set breakpoints at intesting instructions so you can skip benign functions and get to analysing interesting ones quicker
- you can see all the breakpoints you have set, and remove unncessary ones, in the Breakpoints tab
- you can step through a program (repeated F8s) and get to a point where the program hangs a litte, this is most likely where the main() function of the program is. Right click on this function call and select Follow in Dissassembler
- here you can then begin to cross compare tools (i.e. the dissambler Cutter with the debugger x32dbg) 
	- i.e. if the binary makes calls to the Internet you can setup INetSim and WireShark on the Remnux box, use the debugger to get to the point just before the call to a Internet-related Windows API  call (i.e. `InternetOpenW`) and control the binary's flow. You can see what parameter's are pushed onto the stack (to be inserted into the API call) and navigate to where the `URLDOwnlaodToFileW` (or similar download call is made), then step over, to see the packets in WireShark being captured on the remnux box 
	- i.e. if you see a `ShellExecuteW` API call then you know that it will generate host-based signatures so you can set a breakpoint on this call, open up Procmon and filter by the binary's name, and then step over this function call to see all the events this call generates in Procmon
	- i.e. if you identify the binary downloads a malicious file to a location on the computer, you can step through the binary with the debugger to identify when this exactly occurs in the program (i.e. you could look for a call to the `DownloadToFileW`)
- you can control the CPU registry flags in the a debugger (like x32dbg by clicking on them) and change their values from 0 to 1 or vice versa
- this lets you control the flow of a binary in real time as it's being debugged
- i.e. if a `jne` (jump if not zero) instruction is given and the `ZF` (zero flag) is set to 1 then the insturction will no call the given function. But if you change this `ZF` flag to 0 by double clicking on it then this function call will be called by the binary and the program's flow will change 
- you have complete control of a program's flow while it's in the debugger and can control values on the the stack and in the CPU registrys