# Basic Binary Malware Analysis

### Basic Static Analysis

> It involves not running the binary and just inspecting it on disk.

Research:
- get the hash of the file 
- search online for hash of file (i.e. VirusTotal, intzer, hybrid-analysis)

String analysis:
- view the binary file's strings using (floss or strings)
	- i.e. `floss <binary>`
	- use the `-n <#>` argument to specify a minimum number of characters to match for strings
- pick out eaisly identifiable artifacts (i.e. IP addresses, domain names, Windows functions/imports, etc.)
- if there are no IOCs during string analysis then it's likely the binary is packed or the IOCs are being built dynamically at runtime (common tradecraft)


Analyse the Import Address Table (IAT):
- open PEview and load the binary file (by default it will look for `.exe` files so change to All Files if binary is saved with a different extension)
- PEview breaks down the structure of a PE file into it's pre-defined sections 
- things to look at:
	1. the IMAGE_NT_HEADERS section:
		- look at the Time Date Stamp (in IMAGE_FILE_HEADER) as this will reveal information about when the file was compiled 
		- if this says 1982 then it was likely compiled with the Border Delphi compiler (sometimes you can google the time date stamp for compiler information)
		- look at critically to determine if actual time/date binary was compiled
	2. the IMAGE_SECTION_HEADER .text section:
		- compare the Virtual Size to the Size of Raw Data (written in hexadecimal so use programmming calculator to convert HEX to DEC)
		- if the virtual size (size when the binary is ran) is much higher than the raw data size (size on disk), you can deduce that the binary is likely packed 
	3. the IMPORT Address Table (in SECTION .rdata section): 
		- this table contains all the functions imported by the binary from the Windows API 
		- the Windows API lets you interface with the OS through C/C++ function calls and these are documented by Microsoft 
		- looking at the Windows functions imported can indicate what the malware does (i.e. if it connects to the Internet, if it encrypts data with RC4 or another algorithm, etc.)
		- you can use https://malapi.io to lookup malicious APIs and what they may be doing 

Determine if malware is packed:
- packing is compression/encryption mechanism used to make a piece of malware look different from it's original source
- a packer will use a compression stub to compress the original PE into something much smaller -- a PE header, the compression stub, and the compressed PE file
- the stub will unpack the compressed PE file at runtime 
- packing is used to avoid AV by hiding the malware's signatures 
- packed programs can be identified by their lack of imports (and usually include LoadLibraryA and GetProcAddress imports), their entropy, and a much larger virtual size than raw data size.
- inspect IAT to view imports, use PeID to calculate entropy, and use PEview and a programming calculator to compare virtual size to raw data size
 Do evertyhing with PEStudio:
- PEStudio can let you do all the static analysis you need in one application 
- it can hash the file and look up the hash on VirusTotal
- it can detected malware indicators (indicators sections)
- it can get the libraries and functions imported by binary and label suspcious ones (libraries and functions sections)


### Basic Dynamic Analysis

> Also known as heuristic or behavioural analysis. It involves running the binary and seeing what happens. Dymaic analysis produces two types of indicators:
> - **Host indicators** (things that happen to the host) -- i.e. deleting files, installing persistence mechanisms, etc.
> - **Network indicators** (things that  ) -- i.e. calling out to a domain, downloading files, etc.
>
> There can be indicators which are both (i.e. DNS requests) depending on where they are pulled from)

It is important to have all your dynamic analysis tools up and running before detonating the malware (and the VM is isolated):
- INetSim (with DNS resolving to this box) on remnux machine to simulate Internet
- WireShark running on remnux machine to capture traffic packets
- have Procmon (Process Monitor form SysInternals) running on host (FLARE VM) machine -- usefull to use the Filter icon to match events which include the process name of the binary (i.e. Process Name is Malware.Unknown.exe)
- have TCPView running if you suspect the host-based indicators of network events not present on the wire)

Process:
- start dynamic analysis tools (host and network based)
- in Procmon, filter by the binary name as Process Name
- run the binary 
- use strings/static analysis leads to track down host and network based indicators


in Procmon:
- the binary should be set as the Process Name to filter events related to executing the malware
- you can then filter by other things
- i.e. to see all events related to files (created, queried, deleted, etc.): Filter -> `Operation contains File` -- were any files edited? were any files created? was the malware a dropper?
- droppers often uses favicon.ico files as second stage payloads as they are automatically downloaded when you visit a website
- if malware downloads something from the Internet, and you are running INetSim, then it will download a default INetSim exe file
- malware often pings a C2 domain to confirm it is in a legitimate environment and can execute. You can inspect with the filter `Detail contains cmd.exe /C ping` to filter for events that contain the cmd.exe program running the ping program. Then stop INetSim from running and execute the binary to see if this effects it and the ping event occurs and if anything else then happens.
- malware often uses the "AppData\Roaming\Microsoft\Windows\Start Menu\Startup" for persistence. You can filter Procmon to search for events that interact with this file path with `Path contains AppData\Roaming\Microsoft\Windows\Start Menu\Startup` and you may then be able to discover the malware's persistence mechanism (i.e. was a file created here? was it the downloaded file?)
- if you suspect a piece of malware is related to a known malware with known IOCs, you can filter for these IOCs using Procmon 
- use filter `Operation contains TCP` to find TCP events (i.e. network connections)


in WireShark:
- have running at the same time as INetSim to capture traffic
- inpect packets using the highest protocol avaliable (i.e. HTTP)
- look at information like; user-agents, requested URL/URI, requested files, IP addresses, hostnames, DNS requests, etc.
- use Follow TCP (or HTTP) Stream in WireShark of interesting packets to see full network interaction (i.e. request to downloaded binary)
- note, a download from a web resource and the writing too disk can be two seperate transactions, thus the web resource name may be different from filename stored on disk -- called de-chanining/de-coupling and is common tradecraft that makes tracking downloaded files harder
- you can filter network activity by URLs or IPs found during string/static analysis to track down leads 


in TCPView:
- if network activity is occuring, you can use TCPView to inspect host-based indicators that show network signatures which are not on the wire (i.e. opening sockets)
- TCPView shows all network sockets open, the process name assocaited with it, and the state its in. Hence, if a malware sample opens a port and listens on it, then TCPView will be able to show this.
	- note, 0.0.0.0 is shorthand for all network interfaces
- if a connection is opened, you can use netcat on the remnux machine to try and connect to the open port and discover what it is doing (i.e. `nc -nv <flare_ip> <port>`) -- can you send it commands? is it a command injection/execution capable RAT? 
- you can cross-correlate TCPView with Procmon -> filter by Process name, filter by `Operation contains TCP`, then interact with the backdoor or re-run the binary
- you can also look for commands injected via netcat on the FLARE VM machine through Procmon (i.e. filter for `whoami` command)


tricking malware's DNS requests:
- if a malware sample is trying to connect to a domain (you see this request in WireShark on remnux box), you can trick it into connecting to the machine it's on by altering the machine's "hosts" file 
- open cmder as admin -> run `vim \Windows\System32\drivers\etc\hosts` -> add `127.0.0.1 <domain_name>` at the bottom of the file -> save and quit
- then you can run Procmon on the host (FLARE VM) with the filters:
	- `Process Name is <malware_binary>`
	- `Operation contains TCP`
- this will filter for TCP events related to the malware you are running 
- if the binary attempts to make a call to the server the DNS address is associated with, and on a specific port (opens a socket), you can setup a ncat listener (i.e. `ncat -lvnp 443`) on the host machine to accept the connection the binary is trying to make and pretend to be the server 
- if the malware is a RAT, you can try to executing commands to see if you have a reverse shell on the system (i.e. `whoami`)


exploring Procmon's Process Tree:
- the Tools -> Process Tree in Procmon shows you all the processes that are currently running and their relationships to other processes
- this will show you if a malware binary has spawned other processes (i.e. cmd.exe) and can reveal what commands have been run 
- malware author's will try to break (de-chain) this parent-to-child process relationship to hide their malware's actions
- you can get the Process ID of the malware binary and then filter by Parent PID (setting it to that of the binary) to see any processes coming off of that main binary


extracting PowerShell payloads:
- often malware author's will hide PowerShell payloads in compress form (i.e. .zip, .tar.gz, etc.), so if you see/expect PowerShell has been executed then it's usefull to find the command line of this 
- if you see a PowerShell command using a compression command (i.e. `System.IO.Compression.GzipStream`) then you can copy this string, decode it and save it to a file, and finally extract the contents of this file to reveal the uncompressed PowerShell command
- i.e. copy the base64 string the PowerShell command uses -> run `<base64_string> | base64 -d > file.out`  on remnux box -> open the file in a file manager -> extract the file -> open the file to view the full (uncompressed) PowerShell command 
- revealling the full unobfuscated PowerShell command can reveal a lot about the malware's functionality 


detecting encrypted (HTTPS/TLS) reverse shells:
- if the binary attempts to make a call to the server the DNS address is associated with, and on a specific port (opens a socket), you can setup a ncat listener (i.e. `ncat -lvnp 443`) on the host machine to accept the connection the binary is trying to make and pretend to be the server using the DNS tricking above
- if the malware is a RAT, you can try to executing commands to see if you have a reverse shell on the system (i.e. `whoami`)
- if you get back garbage then open WireShark and set it to listen on the local loopback address to inspect the traffic. This is likely to reveal that HTTPS is used and a certificate is required for the TLS  handshake the reverse shell tries to make with the server, thus if you don't have one then the netcat session will be filled with garbage text 
- however, if the malware used Metasploit (or another open source exploitation framework) to generate the reverse shell then you may be able to detect what Metasploit module was used, setup a listener for this module in Kali, and then connect to the reverse shell through this
- i.e. `msfconsole` -> `use exploit/multi/handler` -> `set payload windows/x64/powershell_reverse_tcp` -> set lhost and lport -> `run`



