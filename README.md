# Malware Analysis Methodology

### Malware Binary Analysis

1. basic static analysis:
	- get hashes and lookup on VT (i.e. in PowerShell prompt `Get-FileHash -Algorithm SHA256 <binary>`)
	- get strings (i.e. `floss <binary>.exe > <binary>.strings.txt`)
	- perform string analysis and note interesting strings
	- open binary in PEView and PEStudio to look at IAT and image header information (if a 64-bit executable then use PEStudio or PE-bear)
	- determine if malware is packed (use IAT, string analysis, PeID entropy, compare virtual size and raw on-disk size)

2. basic dynamic analysis:
	- setup all dynamic binary anlaysis tools (Procmon on host, Wireshark on remnux, INetSim on remnux, TCPView on host)
	- detonate the malware
	- search for host-based indicators (filter for events Procmon: files, registery interaction, details)
	- search for network-based indicators (in Procmon TCP in Operation, in Wireshark use the highest protocol avaliable and follow TCP/HTTP streams, in TCPView look for new sockets)
	- during basic dynamic analysis you will do rounds of analysis to find different indicators; you will restore the analysis VM to a pre-detonation state, detonate, collect indicators of what the malware does, restore VM, then detonate again and collect other indicators

3. advanced static analysis 
	- open malware in Cutter
	- find main function (may be dependent on what programming language malware is writter in, i.e. nim = NimMainInner) and right click -> Show In -> New graph to get a basic overview of the malware
	- look for where interesting strings are called in the disassembly to reveal their possible usage 
	- cross compare diassembly with other analysis techniques to confirm functionality (i.e. network-based and host-based indicators from basic analysis)

4. advanced dynamic analysis
	- open malware in x32dbg or x64dbg 
	- press run (F9) to get to the entry point of the program
	- step through program and cross compare host/network-based indicators to reveal functionality of malware 
	- change flag/registry values to get the malware to behave how you want it to 


---
### Maldoc Analysis

Malicious Excel documents (`.xlsm`):
1. transfer to Remnux machine
2. run `oledump.py <file>` to discover embedded macros (streams with `M` or `m` next to them)
3. get a hexdump of the stream with `oledump.py -s <stream> <file>.xlsm`
4. get strings of stream with `oledump.py -s <stream> -S <file>.xlsm`
4. try to recover full macro of stream with `oledump.py -s <stream> --vbadecompresscorrupt <file>.xlsm`

Malicious Word document (`.docm`):
- same process as for malicious Excel document (above)

Malicious Word document (`.docx`) -- malicious templates:
1. save as a `.zip` file and extract contents 
2. navigate to the "word" -> "_rels" directory and open the `settings.xml.refs` file in a text editor -- this file point to the template used to generate the Word document 
3. inspect `Target=...` entry in XML document -- should point to user's Document directory, but bad Document will point to a web resource hosting malware (often a `.docm` template with a malicious macro embedded in it)


--- 
### Shellcode Analysis

1. extract the shellcode and parse it into binary format (i.e. hex code `0x8b` becomes binary code `8b`)
2. anaylse file with Shellcode Debug utility (i.e. `scdbg /f <binary>.bin -s -1`)
3. `scdbg` steps through shellcode and sees what each CPU instruction resolves to a known Windows API call and if these are called with a parameter


--- 
### Scripted Malware Delivery Mechanisms 

PowerShell delivery:
1. open PowerShell malware in VSCode 
2. replace `iex` with a variable name
	- for example, original code:
	```powershell
	iEx(new-object Io.CoMpRESSiOn.defLatEstReam[iO.memoRY][system.convert]::FROmbase64sTRING('...'),...) | % ...)
	```
	- becomes:
	```powershell
	$malware = ew-object Io.CoMpRESSiOn.defLatEstReam[iO.memoRY][system.conver]::FROmbase64sTRING('...'),...) | % ...
	```
3. write out this new variable in a PowerShell terminal (i.e. copy across the code and run `write-host $malware`)
4. deduce what the PowerShell code is intended to do 


VBScript:
1. open VBScript malware in VSCode 
2. try to deobfuscate an look for a call to `MSBuild.exe`
3. find the XML file that is being passed to this utility to build the malware (i.e. `/path/to/MSBuild.exe /path/to/xml.xml`) -- this may have been dropped by the malware or is downloaded so you may need to perform some dynamic analysis 
4. open the XML file in VSCode to inspect it's functionality 
5. if the VBScript contains shellcode then use `scdbg` to analyse it 


--- 
### C# Malware Analysis 

1. deduce if C# has been used to build the malware (i.e. is the `mscorlib` library loaded into binary or are there other indicators in string analysis)
2. open the file in dnSpy to recover the Intermediate Langauge which is stored on disk:
	- navigate through the binary's structure to find interesting functions
	- the decompilation will be very close to the original source code 
	- the Program class will have most of the interesting information about the binary (contains the Main() function)
3. if you are reversing DLLs, you need some vessel/container to run it through (i.e. `rundll32.exe`):
	- use dnSpy to find the method/function used to run all the other functions (i.e. `embed`)
	- run this function by seperating the DLL name with a comma and then the exported function name (i.e. `rundll32.exe Malware.cryptlib64.dll,embed`)
- if you see `System.Reflection.Asssembly.Load()` C# function in a binary, this is a common method used to evade AV/EDR by loading malware into memory before executing it so the code is only avaliable at runtime 


---
### Mobile Malware Analysis 

Static analysis:
1. install MobSF on REMnux machine
	- i.e. run `docker pull opensecurity/mobile-security-framework-mobsf` to install MobSF as a Docker image 
2. start MobSF
	- i.e. run `docker run -it --rm -p 8000:8000 opensecurity/mobile-security-framework-mobsfto:latest` to run the Docker image on port 8000
3. arm the malware (i.e. rename to a `.apk` extension)
4. navigate to the main MobSF web page and upload the mobile malware -- MobSF will analyse this malware and generate a report 
5. deduce what the malware is doing 
	- if application is coded in Java, you will be able to read the source code 

Dynamic analysis:
1. install full version of MobSF (not just Docker image)




a change
another change
third change
