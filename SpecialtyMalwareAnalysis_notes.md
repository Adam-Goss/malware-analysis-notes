# Specialty Malware Analysis

> This includes specialty classes of malware which differ from standard binary malware in their delivery mechanism or operation (i.e. maldocs, shellcode injection, PowerShell, VBS, etc.)


## Maldoc Analysis 

> A maldoc is a malicious document (Word, Excel, PowerPoint, etc.). If you don't have these applications installed then you cannot perform dynamic analysis, however this is very similar to standard binary dynamic analysis where you run the malware and see what happens in a sandboxed envrionment. Note, all Microsoft Office documents are really just `.zip` files with other files inside of them.

Malicious Excel document:
- these usually have a `.xlsm` (Excel document with macros enabled) extension
- first, transfer the file to Remnux machine and use `unzip <file>.xlsm` to extract included documents. These `.xlsm` files contain a host of data which can be extracted by unzipping them as all Office documents are just `.zip` files with other files inside of them.
- checkout any `.bin` files extracted as they contain binary bytes, which is usually VBA code used to program macros 
- next, analyse the malware with `oledump.py`, this program analyses OLE files and extracts useful information that it parses into streams of data (listed as directories, i.e. `A1` = stream 1)
- if the directory extracted by `oledump.py` has a `M` or `m` next to it then it's worth investigating because it contains an embedded macro 
- to get the hexdump of an interesting directory run `oledump.py -s <stream> <file>/xlsm`
	- i.e. `oledump.py -s 3 sheetsForFinancial.xlsm`
- this hexdump can reveal interesting strings, but to get them in a more readable format use the `-S` flag
	- i.e. `oledump.py -s 3 -S sheetsForFinancial.xlsm`
- to try an recover the full macro which has been embedded into the Excel worksheet, you can use the `--vbadecompresscorrupt` option 
	- i.e. `oledump.py -s 3 --vbadecompresscorrupt sheetsForFinancial.xlsm`
- if successful, you can then read this macro to determine to malware's functionality 


Malicious Word document:
- malware delivery in Microsoft Word can take two forms:
	- a) like with Excel documents malware can come in the form of macro-enabled `.docm` documents -- these can be analysed in the exact same way a macro-enabled Excel documents discussed above with `oledump.py`
	- b) in `.docx` Word documents 
- to analyse malware in `.docx` Word documents you can save the malware as a `.zip` file and extract the contents
- next, navigate to the "word" -> "_rels" directory and open the `settings.xml.refs` file in a text editor
- this is the file which points to the template which is going to be used to generate this Word document 
- usually Word downloads a template for the document and stores it in the user's Documents directory and the `Target=...` entry in the XML document points to this 
- however, this target does not have to be something on the local file system and attackers will abuse this to point to a web resource hosting malware (often a `.dotm` template with a malicious macro embedded in it). Thus, when the `.docx` document is run the malicious, macro embedded, template file will be pulled down and automatically run, just as if the original `.docx` document was a `.docm` document 


--- 

## Shellcode Analysis 

> Shellcode found in a program may be benign or malicious. To determine this you need to extract it and analyse it. Shellcode is a serious of instructions passed into the CPU at runtime. 

- first you need to extract the shellcode from the malware sample, if this is a scripted binary where you can see the source code then this can be done in a text editor 
- next, you need to parse this shellcode so that you can carve into it -- this can be done by creating a simple shellcode parser in python:
	```python
	#!/usr/bin/env python3
	
	with open("shellcode.txt", "r") as f:
		hex_string = f.read().replace("0x", "").replace("byte[] rsrc = new byte[464] {", "").replace("};", "").replace(",", "")

		hex_string = hex_string.encode()
		
	with open("out.bin", "wb") as out:
		out.write(hex_encode)
	```
	- this script is malware sample specific, but filters out all other characters to just leave the two characters after the `0x..` (i.e. `0x8b` -> `8b`)
	- next, these text characters are then encoded using the `.encode()` method to generate the raw bytes, which are then written to a binary file
- now transfer the binary file created back to the FLARE-VM box 
	- a) on Remnux setup a Python server
	- b) on FLARE-VM run `wget http://<remnux-ip>/out.bin -UseBasicParsing -OutFile out.bin`
- to now analyse the shellcode you can use **scdbg** (shellcode debug), which will step through the shellcode and resolve API calls to see what the shellcode is doing (it does not run the shellcode, just resolve API calls):
	- i.e. `scdbg /f out.bin -s -1`
	- the `-f` argument specifies a file and `s -1` means step through shellcode for unlimited steps (resolves all the shellcode)
	- `scdbg` steps through shellcode and sees what each CPU instruction resolves to a known Windows API call and if these are called with a parameter
	- this process lets you deduce the functionality of the shellcode and if it is malicious or not 


--- 

## Scripted Malware Delivery Mechanisms

Method 1: PowerShell:
- PowerShell is the interpreter for the .NET framework which can be used as a cmdline utility 
- hackers have moved away from PowerShell in recent times and to Windows built-in C# compiler, but its still prevelent and can bypass systems which don't protect against it's usage 
- hackers often try to obfuscate PowerShell code and, because PowerShell is very malleable, this can be done to the extreme so deobfuscation is the main hurdle when dealing with PowerShell scripted malware 
- first, open the malware in VSCode and make a copy of the original malware. From here, you can then do whatever you want to the copy you made to try and deobfuscate the original malware on your machine 
- `IEX` means `Invoke-Expression` which means anything following this will be executed on the target machine 
- to avoid manually de-obfuscating the PowerShell malware manually, you can replace the `IEX` expression with an variable name to save the PowerShell code invoked to a variable 
- for example, original code:
	```powershell
	iEx(new-object Io.CoMpRESSiOn.defLatEstReam[iO.memoRY][system.convert]::FROmbase64sTRING('...'),...) | % ...)
	```
- becomes:
	```powershell
	$malware = ew-object Io.CoMpRESSiOn.defLatEstReam[iO.memoRY][system.conver]::FROmbase64sTRING('...'),...) | % ...
	```
- then you can write out this variable to the terminal (or a file) to de-obfuscate the code and view the PowerShell:
	- i.e. `write-host $malware`
- scripted malware is avalible for you to be changed (decrypted, decoded, parsed) because it has to be read by the PowerShell interpreter, whereas binary malware (in PE format) is not. This means there is always a way to make the malware do the heavy lifting and de-obfuscate itself, you only need to figure out how to make it do this for you 


Method 2: VBScript:
- Visual Basic is a scripting language that is built into the Windows OS which allows someone to build scripts that are much more enriched than a batch script. This is because you can tap into powerful primitive into the Windows OS to do different scripting things (i.e. creating shell objects to execute things on the machine with `WScript.Shell`)
- like PowerShell, VBScript is avaliable to you on the machine and you can change it to reveal it's functionality if it has been obfuscated 
- it can be helpful when de-obfuscating, or trying to deduce what a VBScript is doing, to use the Microsoft Developer documentation (avaliable online) as this will tell you what a function does and what the parameters passed to it represent 
- `MSBuild.exe` is the utility used with Visual Studio and is used to build things in Visual Studio (i.e. with C#, C++, VBS, etc.) from the cmdline. You pass this utility a XML file which has the information of what you want to build and it will try to build it. 
- if you are able to find a call to `MSBuild.exe` and the XML file which it is called with, you can run this on the cmdline to see what the malware is designed to do (basic dyanmic analysis)
	- i.e. `/path/to/MSBuild.exe /path/to/xml.xml`
	- or you can click on the VBScript file which is designed to run this XML file (i.e. `embed.vbs`) and perform dynamic analysis
- if the VBScript contains shellcode, you can use the `scdbg` utilitiy previously discussed to perform shellcode analysis on the script and deduce what it is designed to do by the Windows API calls it makes and with what parameters


--- 

### C# Malware

- if when you run string analysis (i.e. with floss) and see the **mscorlib** string and a clean binary string output then it is likely that you are working with a C# malware sample 
- C# lives inside the .NET framework which is installed on the Windows OS
- compile languages (i.e. C/C++) use a compiler to create a binary which is then run
- C# uses the CLR (Common Language Runtime) which acts like the engine for the .NET framework, for the execution of it's progams -- C# programs are executed by the CLR
- C# programs use a C# compiler to translate the high-level into an Assembly (same as .exe from the frontend), this is then stored as the IL (Intermediate Language) on disk and is run by the CLR when executed 
- Intermediate Langauge is very easy to reverse engine because of this architectural setup and you can get something very close to the original source code when you reverse engine it
- **mscorlib** is a series of .NET libraries that can be imported when building a C# application and provide functionality for this application. It is assigns these libraries dynamically at runtime.
- with C# binaries you can use **dnSpy** to recover the Intermediate Langauge which is stored on disk:
	- File -> Open -> <binary_name>
	- navigate through the binary's structure to find interesting functions
	- the decompilation will be very close to the original source code 
	- the Program class will have most of the interesting information about the binary (contains the Main() function)
- if you are reversing DLLs, you need some vessel/container to run it through (you cannot run it directly)
	- for instance, you can use the `rundll32.exe` Windows program to run a DLL so long as you know the name of the function the DLL exports for use in another program
	- you can find this using dnSpy and looking for the method/function which is running all the other functions (i.e. `embed`)
	- then you can run it with by seperating the DLL name with a comma and then the exported function name (i.e. `rundll32.exe Malware.cryptlib64.dll,embed`)
- if you see `System.Reflection.Asssembly.Load()` C# function in a binary, this is a common method used to evade AV/EDR by loading malware into memory before executing it so the code is only avaliable at runtime 



--- 

## Go Malware 

- Go is an up and coming programming language used by malware authors as it can cross-compile (with a single code base) to Linux, Windows, and Mac
- there is a lot of strings present in a Go binary which can be used to identify it as being written in Go
	- i.e. `.symtab` section, URLs referencing `golang.org`, the `go-http-client` as the default user agent (or `GRequests`)
	- you can cross reference these indicators in basic dynamic analysis (for the Go default user agent) and looking at the PE headers through PEView/PEStudio/PE-bear (for the `.symtab` section)
- Go binaries tend to be very large, considering the source code used to compile them, and this can be a distinguishing feature 
- all malware coming from source languages have particular characteristics which you can hone in on and, depending on the language, use to track the malware itself in the wild when rule writing (not just Go) 



----

## Mobile Malware Analysis 

> MobSF can be found at:
> - https://github.com/MobSF/Mobile-Security-Framework-MobSF
> - https://mobsf.github.io/docs/#/

Installation of MobSF:
- for mobile malware analysis you need to install tool which does not come pre-installed on the REMnux machine -- the Mobile Security Framework (MobSF)
- first, you need to connect the machien to the Internet to download it 
- run `docker pull opensecurity/mobile-security-framework-mobsf` to install MobSF as a Docker image 
- then `docker run -it --rm -p 8000:8000 opensecurity/mobile-security-framework-mobsfto:latest` run the Docker image on port 8000 on the REMnux host 
- then click on the http://0.0.0.0:8000 link to navigate to the MobSF framework's web homepage 
-  next, close the Docker image and change back the network adapter to Host-only Adapter #2 to disconnect from the Internet and isolate the machine to the malware anlaysis lab network previously created 
- finally, run the Docker command again and take a snapshot when all is working 


Static MobSF Analyzer:
- start MobSF (as above) and transfer the mobile malware to the machine 
- arm the malware (i.e. rename to a `.apk`) extension
- navigate to the main MobSF web page and upload the mobile malware -- MobSF will analyse this malware and generate a report 
- the `.apk` format is a packaged up set of source code for an Android application, if that source code is written in Java then this source code won't be compiled into binary code, instead byte code which is interpreted by the Java virtual machine, so MobSF will be able to completely decompile the Java code all the way back to it's original source code. You can view this in the MobSF report. 
- you can also see if it's a signed APK and ithe application's permissions. These permissions can be very useful in discovering the malware's capability and what it's intended purpose might be.
- you can also see how the APK is interacting with the Android API; this will give you a general gist of what the API is doing (i.e. Execute OS Command) and the particular source code that is responsible for that (i.e. javapayload/stage/Shell.java), which you can click on to navigate to 


Dynamic MobSF Analyzer:
- to use the dyanmic analyzer you need the full version of MobSF (not just the Docker image)
- 